{
  "Leetcode": {
    "prefix": "leetcode",
    "body": [
      "#define sz(x) (int)x.size()",
      "#define ll long long",
      "#define ar array",
      "#define all(x) x.begin(), x.end()",
      "#define pii pair<ll, ll>",
      "#define pb push_back",
      "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
      "#define rint(l, r) uniform_int_distribution<int>(l, r)(rng)",
      "template<typename T> bool ckmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }",
      "template<typename T> bool ckmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }",
      "template<typename T, typename S> constexpr T ifloor(const T a, const S b){return a/b-(a%b&&(a^b)<0);}",
      "template<typename T, typename S> constexpr T iceil(const T a, const S b){return ifloor(a+b-1,b);}",
      "template<typename T> T isqrt(const T &x){T y=sqrt(x+2); while(y*y>x) y--; return y;}",
      "template<typename T>",
      "void sort_unique(vector<T> &vec){",
      "    sort(vec.begin(),vec.end());",
      "    vec.resize(unique(vec.begin(),vec.end())-vec.begin()); ",
      "}",
      "struct _debug {",
      "template<typename T> static void __print(const T &x) {",
      "    if constexpr (is_convertible_v<T, string> || is_fundamental_v<T>) cout << x;",
      "    else { cout << '{'; int f{}; for (auto i : x) cout << (f++?\",\":\"\"), __print(i); cout << '}'; }",
      "}",
      "template<typename T, typename V>",
      "static void __print(const pair<T, V> &x) { cout << '(', __print(x.first), cout << ',', __print(x.second), cout << ')'; }",
      "template<typename T, typename... V>",
      "static void _print(const T& t, const V&... v) { __print(t); if constexpr (sizeof...(v)) cout << \", \", _print(v...); else cout << \"]\\n\"; }",
      "};",
      "#define debug(x...) cout << \"[\" << #x << \"] = [\", _debug::_print(x)"
    ],
    "description": "Snippet for Leetcode"
  },
  "Misc Dlx": {
    "prefix": "dlx",
    "body": [
      "template<int CAP>",
      "struct DLX {",
      "  int n, m, tot, ans;",
      "  int L[CAP], R[CAP], U[CAP], D[CAP], col[CAP], row[CAP];",
      "  vector<int> firstRow, sizCol, stk;",
      "",
      "  void build(int r, int c) {",
      "    n = r; m = c; tot = m; ans = 0;",
      "    for (int i = 0; i <= m; ++i) { L[i] = i - 1; R[i] = i + 1; U[i] = D[i] = i; }",
      "    L[0] = m; R[m] = 0;",
      "    firstRow.assign(n + 1, 0);",
      "    sizCol.assign(m + 1, 0);",
      "    stk.assign(n + 1, 0);",
      "  }",
      "",
      "  void insert(int r, int c) {",
      "    ++tot;",
      "    col[tot] = c; row[tot] = r; ++sizCol[c];",
      "    D[tot] = D[c]; U[D[c]] = tot; U[tot] = c; D[c] = tot;",
      "    if (!firstRow[r]) firstRow[r] = L[tot] = R[tot] = tot;",
      "    else { R[tot] = R[firstRow[r]]; L[R[firstRow[r]]] = tot; L[tot] = firstRow[r]; R[firstRow[r]] = tot; }",
      "  }",
      "",
      "  void remove(int c) {",
      "    L[R[c]] = L[c]; R[L[c]] = R[c];",
      "    for (int i = D[c]; i != c; i = D[i])",
      "      for (int j = R[i]; j != i; j = R[j]) { U[D[j]] = U[j]; D[U[j]] = D[j]; --sizCol[col[j]]; }",
      "  }",
      "",
      "  void recover(int c) {",
      "    for (int i = U[c]; i != c; i = U[i])",
      "      for (int j = L[i]; j != i; j = L[j]) { ++sizCol[col[j]]; U[D[j]] = j; D[U[j]] = j; }",
      "    L[R[c]] = c; R[L[c]] = c;",
      "  }",
      "",
      "  bool dance(int dep = 0) {",
      "    if (R[0] == 0) { ans = dep; return true; }",
      "    int c = R[0];",
      "    for (int j = R[0]; j != 0; j = R[j]) if (sizCol[j] < sizCol[c]) c = j;",
      "    remove(c);",
      "    for (int i = D[c]; i != c; i = D[i]) {",
      "      stk[dep] = row[i];",
      "      for (int j = R[i]; j != i; j = R[j]) remove(col[j]);",
      "      if (dance(dep + 1)) return true;",
      "      for (int j = L[i]; j != i; j = L[j]) recover(col[j]);",
      "    }",
      "    recover(c);",
      "    return false;",
      "  }",
      "};"
    ],
    "description": "Snippet for Misc Dlx"
  },
  "Graphs Hopcroftkarp": {
    "prefix": "hopcroftkarp",
    "body": [
      "struct hopcroftkarp {",
      "    int nL, nR;",
      "    vector<vector<int>> adj;",
      "    vector<int> matchL, matchR, dist;",
      "",
      "    hopcroftkarp(int nL, int nR) : nL(nL), nR(nR), adj(nL), matchL(nL, -1), matchR(nR, -1), dist(nL) {}",
      "",
      "    void add_edge(int u, int v) {",
      "        adj[u].pb(v);",
      "    }",
      "",
      "    bool bfs() {",
      "        queue<int> q;",
      "        bool reachableR = false;",
      "        fill(all(dist), -1);",
      "        for(int u = 0; u < nL; u++) if(matchL[u] == -1) dist[u] = 0, q.push(u);",
      "        while(!q.empty()) {",
      "            auto f = q.front(); q.pop();",
      "            for(auto &e : adj[f]) {",
      "                int v = matchR[e];",
      "                if(v == -1) reachableR = true;",
      "                else if(dist[v] == -1) {",
      "                    dist[v] = dist[f] + 1;",
      "                    q.push(v);",
      "                }",
      "            }",
      "        }",
      "        return reachableR;",
      "    }",
      "",
      "    bool dfs(int u) {",
      "        for(auto&e : adj[u]) {",
      "            auto v = matchR[e];",
      "            if(v == -1 || (dist[v] == dist[u] + 1 && dfs(v))) {",
      "                matchL[u] = e;",
      "                matchR[e] = u;",
      "                return true;",
      "            }",
      "        }",
      "        dist[u] = -1;",
      "        return false;",
      "    }",
      "",
      "    int max_matching() {",
      "        int res = 0;",
      "        while(bfs()) {",
      "            for(int u = 0; u < nL; u++) {",
      "                if(matchL[u] == -1 && dfs(u)) ++res;",
      "            }",
      "        }",
      "        return res;",
      "    }",
      "};"
    ],
    "description": "Snippet for Graphs Hopcroftkarp"
  },
  "Graphs Dsu": {
    "prefix": "dsu",
    "body": [
      "struct DSU {",
      "    vector<int> f, siz;",
      "    ",
      "    DSU() {}",
      "    DSU(int n) {",
      "        init(n);",
      "    }",
      "    ",
      "    void init(int n) {",
      "        f.resize(n);",
      "        iota(f.begin(), f.end(), 0);",
      "        siz.assign(n, 1);",
      "    }",
      "    ",
      "    int find(int x) {",
      "        while (x != f[x]) {",
      "            x = f[x] = f[f[x]];",
      "        }",
      "        return x;",
      "    }",
      "    ",
      "    bool same(int x, int y) {",
      "        return find(x) == find(y);",
      "    }",
      "    ",
      "    bool merge(int x, int y) {",
      "        x = find(x);",
      "        y = find(y);",
      "        if (x == y) {",
      "            return false;",
      "        }",
      "        siz[x] += siz[y];",
      "        f[y] = x;",
      "        return true;",
      "    }",
      "    ",
      "    int size(int x) {",
      "        return siz[find(x)];",
      "    }",
      "};"
    ],
    "description": "Snippet for Graphs Dsu"
  },
  "Graphs Dinic": {
    "prefix": "dinic",
    "body": [
      "struct Dinic {",
      "    struct Edge { int to, rev, cap; bool real; };",
      "    int n, s, t;",
      "    vector<vector<Edge>> g;",
      "    vector<int> level, it;",
      "",
      "    Dinic(int n): n(n), g(n), level(n), it(n) {}",
      "",
      "    void add_edge(int u, int v, int c) {",
      "        Edge a{v, (int)g[v].size(), c, true};",
      "        Edge b{u, (int)g[u].size(), 0, false};",
      "        g[u].pb(a);",
      "        g[v].pb(b);",
      "    }",
      "",
      "    bool bfs() {",
      "        fill(all(level), -1);",
      "        queue<int> q;",
      "        level[s] = 0; q.push(s);",
      "        while (!q.empty()) {",
      "            int u = q.front(); q.pop();",
      "            for (auto &e : g[u]) if (e.cap > 0 && level[e.to] < 0) {",
      "                level[e.to] = level[u] + 1;",
      "                q.push(e.to);",
      "            }",
      "        }",
      "        return level[t] >= 0;",
      "    }",
      "",
      "    int dfs(int u, int f) {",
      "        if (!f || u == t) return f;",
      "        for (int &i = it[u]; i < sz(g[u]); i++) {",
      "            auto &e = g[u][i];",
      "            if (e.cap > 0 && level[e.to] == level[u] + 1) {",
      "                int pushed = dfs(e.to, min(f, e.cap));",
      "                if (pushed) {",
      "                    e.cap -= pushed;",
      "                    g[e.to][e.rev].cap += pushed;",
      "                    return pushed;",
      "                }",
      "            }",
      "        }",
      "        return 0;",
      "    }",
      "",
      "    int max_flow(int S, int T) {",
      "        s = S; t = T;",
      "        int flow = 0;",
      "        while (bfs()) {",
      "            fill(all(it), 0);",
      "            while (int pushed = dfs(s, 4e18)) flow += pushed;",
      "        }",
      "        return flow;",
      "    }",
      "",
      "    vector<vector<int>> recover_path(int S, int T) {",
      "        vector<vector<int>> paths;",
      "        while (true) {",
      "            vector<int> par_v(n, -1), par_e(n, -1);",
      "            queue<int> q; q.push(S); par_v[S] = S;",
      "            while (!q.empty() && par_v[T] == -1) {",
      "                int u = q.front(); q.pop();",
      "                for (int i = 0; i < sz(g[u]); i++) {",
      "                    auto &e = g[u][i];",
      "                    if (par_v[e.to] == -1 && e.real && g[e.to][e.rev].cap > 0) {",
      "                        par_v[e.to] = u; par_e[e.to] = i;",
      "                        q.push(e.to);",
      "                    }",
      "                }",
      "            }",
      "            if (par_v[T] == -1) break;",
      "            vector<int> path;",
      "            for (int v = T; v != S; v = par_v[v]) path.pb(v);",
      "            path.pb(S);",
      "            reverse(all(path));",
      "            for (int v = T; v != S; v = par_v[v]) {",
      "                int u = par_v[v], i = par_e[v];",
      "                auto &e = g[u][i];",
      "                e.cap += 1;",
      "                g[e.to][e.rev].cap -= 1;",
      "            }",
      "            paths.pb(path);",
      "        }",
      "        return paths;",
      "    }",
      "};"
    ],
    "description": "Snippet for Graphs Dinic"
  },
  "Graphs Dijkstra": {
    "prefix": "dijkstra",
    "body": [
      "vector<int> dijkstra(int s, vector<vector<pair<int,int>>> &adj){",
      "    int n = sz(adj);",
      "    vector<int> dist(n, 4e18);",
      "    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;",
      "    dist[s] = 0; pq.push({0, s});",
      "    while (!pq.empty()){",
      "        auto [d, u] = pq.top(); pq.pop();",
      "        if (d != dist[u]) continue;",
      "        for (auto &[v, w] : adj[u]) if (ckmin(dist[v], d + w)) pq.push({dist[v], v});",
      "    }",
      "    return dist;",
      "}"
    ],
    "description": "Snippet for Graphs Dijkstra"
  },
  "Graphs Bridges": {
    "prefix": "bridges",
    "body": [
      "vector<pii> bridges(int n, const vector<vector<int>> &adj) {",
      "    vector<int> tin(n, -1), low(n, 0), vis(n, 0);",
      "    int timer = 0;",
      "    vector<pii> res;",
      "",
      "    auto dfs = [&](auto &&s, int u, int p) -> void {",
      "        vis[u] = 1;",
      "        tin[u] = low[u] = timer++;",
      "        for (int v : adj[u]) {",
      "            if (v == p) continue;",
      "            if (vis[v]) {",
      "                low[u] = min(low[u], tin[v]);",
      "            } else {",
      "                s(s, v, u);",
      "                low[u] = min(low[u], low[v]);",
      "                if (low[v] > tin[u]) res.pb({u, v});",
      "            }",
      "        }",
      "    };",
      "",
      "    for (int i = 0; i < n; i++) if (!vis[i]) dfs(dfs, i, -1);",
      "    return res;",
      "}"
    ],
    "description": "Snippet for Graphs Bridges"
  },
  "Graphs St Bridges": {
    "prefix": "st_bridges",
    "body": [
      "vector<pii> st_bridges(int n, const vector<vector<int>> &adj, int s, int t) {",
      "    vector<int> tin(n, -1), low(n, 0), vis(n, 0);",
      "    vector<int> hasT(n, 0);",
      "    int timer = 0;",
      "    vector<pii> res;",
      "",
      "    auto dfs = [&](auto &&self, int u, int p) -> void {",
      "        vis[u] = 1;",
      "        tin[u] = low[u] = timer++;",
      "        hasT[u] = (u == t);",
      "        for (int v : adj[u]) {",
      "            if (v == p) continue;",
      "            if (vis[v]) {",
      "                low[u] = min(low[u], tin[v]);",
      "            } else {",
      "                self(self, v, u);",
      "                low[u] = min(low[u], low[v]);",
      "                if (low[v] > tin[u] && hasT[v]) res.pb({u, v}); ",
      "                hasT[u] = hasT[u] | hasT[v];",
      "            }",
      "        }",
      "    };",
      "",
      "    if (!vis[s]) dfs(dfs, s, -1);",
      "    return res;",
      "}"
    ],
    "description": "Snippet for Graphs St Bridges"
  },
  "Graphs Trie": {
    "prefix": "trie",
    "body": [
      "struct trie {",
      "    static const int MX = 1e6 + 5;",
      "    int cnt;",
      "    int nex[MX][26];",
      "    bool exist[MX];",
      "",
      "    trie() { init(); }",
      "",
      "    void init() {",
      "        cnt = 0;",
      "        memset(nex, -1, sizeof(nex));",
      "        memset(exist, 0, sizeof(exist));",
      "    }",
      "",
      "    void insert(const string &s) {",
      "        int vtx = 0;",
      "        for (char c : s) {",
      "            int d = c - 'a';",
      "            int &nx = nex[vtx][d];",
      "            if (nx == -1) nx = ++cnt;",
      "            vtx = nx;",
      "        }",
      "        exist[vtx] = true;",
      "    }",
      "",
      "    string search(string &s) {",
      "        int vtx = 0; string ans;",
      "        for (char c : s) {",
      "            int d = c - 'a';",
      "            ans += c;",
      "            int nx = nex[vtx][d];",
      "            if (nx == -1) return s;",
      "            vtx = nx;",
      "            if (exist[vtx]) return ans;",
      "        }",
      "        return s;",
      "    }",
      "};"
    ],
    "description": "Snippet for Graphs Trie"
  },
  "Graphs Rollbackdsu": {
    "prefix": "rollbackdsu",
    "body": [
      "struct RollbackUnionFind {",
      "  vector<int> data;",
      "  stack<pair<int, int> > history;",
      "  int inner_snap;",
      "",
      "  RollbackUnionFind(int sz) : inner_snap(0) { data.assign(sz, -1); }",
      "",
      "  bool unite(int x, int y) {",
      "    x = find(x), y = find(y);",
      "    history.emplace(x, data[x]);",
      "    history.emplace(y, data[y]);",
      "    if (x == y) return false;",
      "    if (data[x] > data[y]) swap(x, y);",
      "    data[x] += data[y];",
      "    data[y] = x;",
      "    return true;",
      "  }",
      "",
      "  int find(int k) {",
      "    if (data[k] < 0) return k;",
      "    return find(data[k]);",
      "  }",
      "",
      "  int same(int x, int y) { return find(x) == find(y); }",
      "",
      "  int size(int k) { return (-data[find(k)]); }",
      "",
      "  void undo() {",
      "    data[history.top().first] = history.top().second;",
      "    history.pop();",
      "    data[history.top().first] = history.top().second;",
      "    history.pop();",
      "  }",
      "",
      "  void snapshot() { inner_snap = int(history.size() >> 1); }",
      "",
      "  int get_state() { return int(history.size() >> 1); }",
      "",
      "  void rollback(int state = -1) {",
      "    if (state == -1) state = inner_snap;",
      "    state <<= 1;",
      "    assert(state <= (int)history.size());",
      "    while (state < (int)history.size()) undo();",
      "  }",
      "};"
    ],
    "description": "Snippet for Graphs Rollbackdsu"
  },
  "Graphs Lca": {
    "prefix": "lca",
    "body": [
      "struct LCA {",
      "    int n, LOG, root;",
      "    const vector<vector<int>> &adj;",
      "    vector<int> depth;",
      "    vector<vector<int>> up;",
      "",
      "    LCA(const vector<vector<int>> &adj, int root = 0) : n(sz(adj)), LOG(0), root(root), adj(adj) {",
      "        while ((1 << LOG) <= n) ++LOG;",
      "        depth.assign(n, 0);",
      "        up.assign(n, vector<int>(LOG, root));",
      "        vector<int> par(n, root), st; st.pb(root);",
      "        vector<int> vis(n, 0); vis[root] = 1;",
      "        while (!st.empty()) {",
      "            int u = st.back(); st.pop_back();",
      "            up[u][0] = par[u];",
      "            for (int j = 1; j < LOG; j++) up[u][j] = up[up[u][j - 1]][j - 1];",
      "            for (int v : adj[u]) if (!vis[v]) { vis[v] = 1; par[v] = u; depth[v] = depth[u] + 1; st.pb(v); }",
      "        }",
      "    }",
      "",
      "    int jump(int u, int k) const {",
      "        for (int j = 0; j < LOG; j++) if (k >> j & 1) u = up[u][j];",
      "        return u;",
      "    }",
      "",
      "    int lca(int u, int v) const {",
      "        if (depth[u] < depth[v]) swap(u, v);",
      "        u = jump(u, depth[u] - depth[v]);",
      "        if (u == v) return u;",
      "        for (int j = LOG - 1; j >= 0; j--) if (up[u][j] != up[v][j]) { u = up[u][j]; v = up[v][j]; }",
      "        return up[u][0];",
      "    }",
      "",
      "    int dist(int u, int v) const {",
      "        int w = lca(u, v);",
      "        return depth[u] + depth[v] - 2 * depth[w];",
      "    }",
      "};"
    ],
    "description": "Snippet for Graphs Lca"
  },
  "Graphs Cycle Detection Directed": {
    "prefix": "cycle_detection_directed",
    "body": [
      "vector<int> color(n, 0), par(n, -1), cyc;",
      "bool cycle = false;",
      "int cu = -1, cv = -1;",
      "auto dfs = [&](auto &&s, int u) -> void {",
      "    color[u] = 1;",
      "    for (int v : adj[u]) {",
      "        if (cycle) return;",
      "        if (color[v] == 0) { par[v] = u; s(s, v); }",
      "        else if (color[v] == 1) { cycle = true; cu = u; cv = v; return; }",
      "    }",
      "    color[u] = 2;",
      "};",
      "for (int i = 0; i < n && !cycle; i++) if (color[i] == 0) dfs(dfs, i);",
      "if (cycle) {",
      "    int x = cu;",
      "    cyc.pb(cv);",
      "    while (x != cv) { cyc.pb(x); x = par[x]; }",
      "    reverse(all(cyc));",
      "}"
    ],
    "description": "Snippet for Graphs Cycle Detection Directed"
  },
  "Range Query Segtree": {
    "prefix": "segtree",
    "body": [
      "template <class T>",
      "struct segtree {",
      "    const int N; vector<T> tree;",
      "    segtree(int n) : N(1<<(__lg(n)+1)), tree(2*N) {}",
      "    void update(int pos, T x) {",
      "        for (int i = pos+N; i > 0; i >>= 1) ckmax(tree[i], x);",
      "    }",
      "    T query(int node, int nl, int nr, int ql, int qr) {",
      "        if (ql > nr || qr < nl) return 0;",
      "        if (ql <= nl && nr <= qr) return tree[node];",
      "        int mid = (nl+nr)/2;",
      "        return max(query(node*2, nl, mid, ql, qr), query(node*2+1, mid+1, nr, ql, qr));",
      "    }",
      "    T query(int l, int r) { return query(1, 0, N-1, l, r); }",
      "};",
      ""
    ],
    "description": "Snippet for Range Query Segtree"
  },
  "Range Query Lazyseg Min": {
    "prefix": "lazyseg_min",
    "body": [
      "template<class T> struct segtree {",
      "    const int N; vector<T> tree, lazy;",
      "    segtree(int n) : N(1<<(__lg(n)+1)), tree(2*N), lazy(2*N) {}",
      "    void push(int node) {",
      "        if (lazy[node]) {",
      "            tree[node] += lazy[node];",
      "            if (node < N) lazy[node*2] += lazy[node], lazy[node*2+1] += lazy[node];",
      "            lazy[node] = 0;",
      "        }",
      "    }",
      "    void update(int node, int nl, int nr, int ql, int qr, T v) {",
      "        push(node);",
      "        if (ql > nr || qr < nl) return;",
      "        if (ql <= nl && nr <= qr) {",
      "            lazy[node] += v, push(node);",
      "            return;",
      "        }",
      "        int mid = (nl+nr)/2;",
      "        update(node*2, nl, mid, ql, qr, v);",
      "        update(node*2+1, mid+1, nr, ql, qr, v);",
      "        tree[node] = min(tree[node*2], tree[node*2+1]);",
      "    }",
      "    T query(int node, int nl, int nr, int ql, int qr) {",
      "        if (ql > nr || qr < nl) return numeric_limits<T>::max();",
      "        push(node);",
      "        if (ql <= nl && nr <= qr) return tree[node];",
      "        int mid = (nl+nr)/2;",
      "        return min(query(node*2, nl, mid, ql, qr), query(node*2+1, mid+1, nr, ql, qr));",
      "    }",
      "    void update(int l, int r, T v) { update(1, 0, N-1, l, r, v); }",
      "    T query(int l, int r) { return query(1, 0, N-1, l, r); }",
      "};"
    ],
    "description": "Snippet for Range Query Lazyseg Min"
  },
  "Range Query Fenwick": {
    "prefix": "fenwick",
    "body": [
      "template<typename T> struct fenwick {",
      "    int n; vector<T> bit;",
      "    fenwick(int a) : n(a), bit(a+1) {}",
      "    T sum(int pos) {",
      "        T s = 0;",
      "        for (; pos; s += bit[pos], pos -= pos&-pos);",
      "        return s;",
      "    }",
      "    T query(int l, int r) {",
      "        return sum(r+1) - sum(l);",
      "    }",
      "    void update(int pos, T x) {",
      "        pos++;",
      "        for (; pos <= n; bit[pos] += x, pos += pos&-pos);",
      "    }",
      "};",
      "",
      "//outside is all 0-indexed, inclusive, so [l, r]",
      "//don't add 1 to update;"
    ],
    "description": "Snippet for Range Query Fenwick"
  },
  "Range Query Lazyseg Iterative": {
    "prefix": "lazyseg_iterative",
    "body": [
      "const ll MX = 1e5+5;",
      "ll n, a[MX], t[MX*3], mk[MX*3];",
      "",
      "void build(ll l, ll r, ll p) {",
      "    if(l == r) {",
      "        t[p] = a[l];",
      "        return;",
      "    }",
      "    ll m = l + ((r-l)>>1);",
      "    build(l, m, p<<1), build(m+1, r, (p<<1)|1);",
      "    t[p] = t[p<<1] + t[(p<<1)|1];",
      "}",
      "",
      "void push(ll tl, ll tr, ll p, ll m) {",
      "    if(mk[p]) {",
      "        t[p<<1] += mk[p]*(m-tl+1), t[(p<<1)|1] += mk[p]*(tr-m);",
      "        mk[p<<1] += mk[p], mk[(p<<1)|1] += mk[p];",
      "    }",
      "    mk[p] = 0;",
      "}",
      "",
      "void update(ll l, ll r, ll tl, ll tr, ll p, ll c) {",
      "    if(l<=tl && tr<=r) {",
      "        t[p] += (tr-tl+1)*c, mk[p]+=c;",
      "        return;",
      "    }",
      "    ll m = tl + ((tr-tl)>>1);",
      "    push(tl, tr, p, m);",
      "    if(l<=m) update(l, r, tl, m, p<<1, c);",
      "    if(r>m) update(l, r, m+1, tr, (p<<1)|1, c);",
      "    t[p] = t[p<<1] + t[(p<<1)|1];",
      "}",
      "",
      "ll getsum(ll l, ll r, ll tl, ll tr, ll p) {",
      "    if(l<=tl && tr<=r) return t[p];",
      "    ll sum = 0;",
      "    ll m = tl + ((tr-tl)>>1);",
      "    push(tl, tr, p, m);",
      "    if(l<=m) sum+=getsum(l, r, tl, m, p<<1);",
      "    if(r>m) sum+=getsum(l, r, m+1, tr, (p<<1)|1);",
      "    return sum;",
      "}"
    ],
    "description": "Snippet for Range Query Lazyseg Iterative"
  },
  "Range Query Sparse": {
    "prefix": "sparse",
    "body": [
      "template<typename it, typename bin_op>",
      "struct sparse_table {",
      "    using T = typename remove_reference<decltype(*declval<it>())>::type;",
      "    vector<vector<T>> t; bin_op F;",
      " ",
      "    sparse_table(it first, it last, bin_op op) : t(1), F(op) {",
      "        int n = distance(first, last);",
      "        t.assign(32-__builtin_clz(n), vector<T>(n));",
      "        t[0].assign(first, last);",
      "        for (int i = 1; i < sz(t); i++)",
      "            for (int j = 0; j < n-(1<<i)+1; j++)",
      "                t[i][j] = F(t[i-1][j], t[i-1][j+(1<<(i-1))]);",
      "    }",
      " ",
      "    T query(int l, int r) {",
      "        int h = 31 - __builtin_clz(r-l+1);",
      "        return F(t[h][l], t[h][r-(1<<h)+1]);",
      "    }",
      "};"
    ],
    "description": "Snippet for Range Query Sparse"
  },
  "Range Query Lazyseg": {
    "prefix": "lazyseg",
    "body": [
      "template<class T> struct segtree {",
      "    const int N; vector<T> tree, lazy, size;",
      "    segtree(int n) : N(1<<(__lg(n)+1)), tree(2*N), lazy(2*N), size(2*N) {",
      "        for (int i = 0; i < n; i++) size[i+N] = 1;",
      "        for (int i = N-1; i >= 1; i--) size[i] = size[i*2] + size[i*2+1];",
      "    }",
      "    void push(int node) {",
      "        if (lazy[node]) {",
      "            tree[node] += lazy[node] * size[node];",
      "            if (node < N) lazy[node*2] += lazy[node], lazy[node*2+1] += lazy[node];",
      "            lazy[node] = 0;",
      "        }",
      "    }",
      "    void update(int node, int nl, int nr, int ql, int qr, T v) {",
      "        push(node);",
      "        if (ql > nr || qr < nl) return;",
      "        if (ql <= nl && nr <= qr) {",
      "            lazy[node] += v, push(node);",
      "            return;",
      "        }",
      "        int mid = (nl+nr)/2;",
      "        update(node*2, nl, mid, ql, qr, v);",
      "        update(node*2+1, mid+1, nr, ql, qr, v);",
      "        tree[node] = tree[node*2] + tree[node*2+1];",
      "    }",
      "    T query(int node, int nl, int nr, int ql, int qr) {",
      "        push(node);",
      "        if (ql > nr || qr < nl) return 0;",
      "        if (ql <= nl && nr <= qr) return tree[node];",
      "        int mid = (nl+nr)/2;",
      "        return query(node*2, nl, mid, ql, qr) + query(node*2+1, mid+1, nr, ql, qr);",
      "    }",
      "    void update(int l, int r, T v) { update(1, 0, N-1, l, r, v); }",
      "    T query(int l, int r) { return query(1, 0, N-1, l, r); }",
      "};"
    ],
    "description": "Snippet for Range Query Lazyseg"
  },
  "Range Query Segtree Iterative": {
    "prefix": "segtree_iterative",
    "body": [
      "struct segtree {",
      "    int n; vector<int> t;",
      "    segtree(int siz) {",
      "        n = siz;",
      "        t.assign(2 * n, 0);",
      "        for(int i = n-1; i>0; i--) t[i] = min(t[i<<1], t[i<<1|1])",
      "    }",
      "",
      "    void update(int p, int val) {",
      "        for(t[p+=n] = val; p > 1; p >>= 1) t[p>>1] = min(t[p], t[p^1]);",
      "    }",
      "",
      "    //[l, r)",
      "    int query(int l, int r) {",
      "        int res = 4e18;",
      "        for(l += n, r += n; l < r; l >>= 1, r >>= 1) {",
      "            if(l&1) ckmin(res, t[l++]);",
      "            if(r&1) ckmin(res, t[--r]);",
      "        }",
      "        return res;",
      "    }",
      "};"
    ],
    "description": "Snippet for Range Query Segtree Iterative"
  },
  "Strings Hash": {
    "prefix": "hash",
    "body": [
      "const int hash_mod = 1e9+7;",
      "int binpow(int a, int b) {",
      "    int r = 1;",
      "    for (; b > 0; b >>= 1, a = (long long)a*a%hash_mod) if (b&1) r = (long long)r*a%hash_mod;",
      "    return r;",
      "}",
      "const int b_N = 2;",
      "bool init_ = 0;",
      "array<int, b_N> bases;",
      "void init() {",
      "    for (int i = 0; i < b_N; i++) {",
      "        bases[i] = rint(2, hash_mod-1);",
      "    }",
      "}",
      "template<typename T> struct Hash {",
      "    array<vector<int>, b_N> pref, inv;",
      "    Hash(const T& s) {",
      "        if (!init_) init(), init_ = 1;",
      "        int n = s.size();",
      "        for (int i = 0; i < b_N; i++) {",
      "            pref[i].resize(n), inv[i].resize(n);",
      "            inv[i][n-1] = binpow(binpow(bases[i], n-1), hash_mod-2);",
      "            for (int j = n-2; j >= 0; j--) inv[i][j] = (long long)inv[i][j+1] * bases[i] % hash_mod;",
      "            for (int j = 0, b = 1; j < n; j++, b = (long long)b * bases[i] % hash_mod) {",
      "                pref[i][j] = (j?pref[i][j-1]:0) + (long long)b*(int(s[j])+2)%hash_mod;",
      "                if (pref[i][j] >= hash_mod) pref[i][j] -= hash_mod;",
      "            }",
      "        }",
      "    }",
      "    array<int, b_N> query(int l, int r) const {",
      "        array<int, b_N> ret;",
      "        for (int i = 0; i < b_N; i++) {",
      "            ret[i] = pref[i][r] - (l?pref[i][l-1]:0);",
      "            if (ret[i] < 0) ret[i] += hash_mod;",
      "            ret[i] = (long long)ret[i] * inv[i][l] % hash_mod;",
      "        }",
      "        return ret;",
      "    }",
      "};"
    ],
    "description": "Snippet for Strings Hash"
  },
  "Math Matrix": {
    "prefix": "matrix",
    "body": [
      "template<typename T, class Add, class Mul>",
      "struct matrix {",
      "    int n;",
      "    vector<T> a;",
      "    Add add;",
      "    Mul mul;",
      "    T add_id;",
      "    T mul_id;",
      "    matrix(int _n, Add _add, Mul _mul, T _add_id, T _mul_id)",
      "        : n(_n), a(n * n), add(_add), mul(_mul), add_id(_add_id), mul_id(_mul_id) {}",
      "    static matrix identity(int n, Add add, Mul mul, T add_id, T mul_id) {",
      "        matrix m(n, add, mul, add_id, mul_id);",
      "        for (int i = 0; i < n; ++i) m(i,i) = mul_id;",
      "        return m;",
      "    }",
      "    T& operator()(int i, int j) { return a[i * n + j]; }",
      "    T operator()(int i, int j) const { return a[i * n + j]; }",
      "    matrix operator*(const matrix &rhs) const {",
      "        matrix res(n, add, mul, add_id, mul_id);",
      "        for (int i = 0; i < n * n; ++i) res.a[i] = add_id;",
      "        for (int i = 0; i < n; ++i) {",
      "            for (int k = 0; k < n; ++k) {",
      "                T x = (*this)(i,k);",
      "                for (int j = 0; j < n; ++j) {",
      "                    res(i,j) = add(res(i,j), mul(x, rhs(k,j)));",
      "                }",
      "            }",
      "        }",
      "        return res;",
      "    }",
      "    matrix pow(long long e) const {",
      "        matrix base = *this;",
      "        matrix res = identity(n, add, mul, add_id, mul_id);",
      "        while (e > 0) {",
      "            if (e & 1) res = res * base;",
      "            base = base * base;",
      "            e >>= 1;",
      "        }",
      "        return res;",
      "    }",
      "    vector<T> apply(const vector<T> &v) const {",
      "        vector<T> out(n, add_id);",
      "        for (int i = 0; i < n; ++i) {",
      "            for (int j = 0; j < n; ++j) {",
      "                out[i] = add(out[i], mul((*this)(i,j), v[j]));",
      "            }",
      "        }",
      "        return out;",
      "    }",
      "};"
    ],
    "description": "Snippet for Math Matrix"
  },
  "Math Fwht": {
    "prefix": "fwht",
    "body": [
      "void fwht(vector<ll>& a, bool inv) {",
      "\tint w = __lg(sz(a));",
      "\tfor (int i = 0; i < w; i++) {",
      "\t\tfor (int j = 0; j < 1 << w; j += 1 << (i+1)) {",
      "\t\t\tfor (int k = 0; k < 1 << i; k++) {",
      "\t\t\t\tauto l = a[j+k], r = a[(j+k) ^ 1 << i];",
      "\t\t\t\ta[j+k] = (l + r) >> inv;",
      "\t\t\t\ta[(j+k) ^ 1 << i] = (l - r) >> inv;",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "Snippet for Math Fwht"
  },
  "Math Mint": {
    "prefix": "mint",
    "body": [
      "template <int MOD_> struct modnum {",
      "    static constexpr int MOD = MOD_;",
      "",
      "    int v;",
      "",
      "    modnum() : v(0) {}",
      "    modnum(int v_) : v(v_ % MOD) { if (v < 0) v += MOD; }",
      "",
      "    explicit operator int() const { return v; }",
      "    explicit operator bool() const { return v; }",
      "",
      "    friend ostream& operator << (ostream& out, const modnum& n) { return out << n.v; }",
      "    friend istream& operator >> (istream& in, modnum& n) { int v_; in >> v_; n = modnum(v_); return in; }",
      "",
      "    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }",
      "    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }",
      "",
      "    modnum operator- () const {",
      "        return neg();",
      "    }",
      "    modnum operator+ () const {",
      "        return modnum(*this);",
      "    }",
      "",
      "    modnum& operator ++ () {",
      "        v++;",
      "        if (v == MOD) v = 0;",
      "        return *this;",
      "    }",
      "    modnum& operator -- () {",
      "        if (v == 0) v = MOD;",
      "        v--;",
      "        return *this;",
      "    }",
      "    modnum& operator += (const modnum& o) {",
      "        v -= MOD-o.v;",
      "        v = (v < 0) ? v + MOD : v;",
      "        return *this;",
      "    }",
      "    modnum& operator -= (const modnum& o) {",
      "        v -= o.v;",
      "        v = (v < 0) ? v + MOD : v;",
      "        return *this;",
      "    }",
      "    modnum& operator *= (const modnum& o) {",
      "        v = v * o.v % MOD;",
      "        return *this;",
      "    }",
      "",
      "    friend modnum binpow(modnum a, int p) {",
      "        if (p == 0) return 1;",
      "        modnum ret = 1;",
      "        for (; p; p /= 2, a *= a) if (p&1) ret *= a;",
      "        return ret;",
      "    }",
      "",
      "    modnum inv() const {",
      "        return binpow(*this, MOD-2);",
      "    }",
      "    friend modnum inv(const modnum& m) { return m.inv(); }",
      "",
      "    modnum& operator /= (const modnum& o) {",
      "        return *this *= o.inv();",
      "    }",
      "",
      "    modnum neg() const {",
      "        modnum res;",
      "        res.v = v ? MOD-v : 0;",
      "        return res;",
      "    }",
      "    friend modnum neg(const modnum& m) { return m.neg(); }",
      "",
      "    friend modnum operator ++ (modnum& a, int32_t) { modnum r = a; ++a; return r; }",
      "    friend modnum operator -- (modnum& a, int32_t) { modnum r = a; --a; return r; }",
      "    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }",
      "    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }",
      "    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }",
      "    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }",
      "};",
      "",
      "const int mod = 1e9+7;",
      "using mint = modnum<mod>;",
      "",
      "vector<mint> facs, invfacs;",
      "",
      "mint choose(int _a, int _b) {",
      "    if (_b > _a || _a < 0 || _b < 0) return 0;",
      "    return facs[_a] * invfacs[_b] * invfacs[_a-_b];",
      "}",
      "",
      "void finit(const int nx) {",
      "    facs.resize(nx+1);",
      "    invfacs.resize(nx+1);",
      "    facs[0] = facs[1] = invfacs[0] = invfacs[1] = 1;",
      "    for (int i = 2; i <= nx; i++) {",
      "        facs[i] = facs[i-1] * mint(i);",
      "    }",
      "    invfacs[nx] = inv(facs[nx]);",
      "    for (int i = nx-1; i > 1; i--) {",
      "        invfacs[i] = invfacs[i+1] * mint(i+1);",
      "    }",
      "}"
    ],
    "description": "Snippet for Math Mint"
  },
  "Math Linearsieve": {
    "prefix": "linearsieve",
    "body": [
      "template <int N>",
      "struct sieve {",
      "    vector<int> primes;",
      "    array<int, N+1> spf;",
      "    sieve() : spf() {",
      "        for (int i = 2; i <= N; i++) {",
      "            if (!spf[i]) {",
      "                spf[i] = i;",
      "                primes.push_back(i);",
      "            }",
      "            for (int j = 0; i * primes[j] <= N; j++) {",
      "                spf[i*primes[j]] = primes[j];",
      "                if (primes[j] == spf[i]) break;",
      "            }",
      "        }",
      "    }",
      "    bool prime(int x) const {",
      "        return spf[x] == x;",
      "    }",
      "    vector<int> facs(int x) const {",
      "        vector<int> ret;",
      "        while (x != 1) {",
      "            ret.push_back(spf[x]);",
      "            x /= spf[x];",
      "        }",
      "        return ret;",
      "    }",
      "    vector<array<int, 2>> facs2(int x) const {",
      "        vector<array<int, 2>> ret;",
      "        while (x != 1) {",
      "            if (!ret.empty() && ret.back()[0] == spf[x]) ret.back()[1]++;",
      "            else ret.push_back({spf[x], 1});",
      "            x /= spf[x];",
      "        }",
      "        return ret;",
      "    }",
      "    vector<int> divs(int x) const {",
      "        vector<int> divisors(1, 1);",
      "        while (x > 1) {",
      "            int p = spf[x], c = 0;",
      "            while (x % p == 0) x /= p, c++;",
      "            int sz = divisors.size();",
      "            divisors.reserve(sz*(c+1));",
      "            for (int i = 1, pw = p; i <= c; i++, pw *= p) {",
      "                for (int j = 0; j < sz; j++) {",
      "                    divisors.push_back(divisors[j] * pw);",
      "                }",
      "            }",
      "        }",
      "        return divisors;",
      "    }",
      "};"
    ],
    "description": "Snippet for Math Linearsieve"
  }
}