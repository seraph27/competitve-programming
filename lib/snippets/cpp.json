{
  "Segtree": {
    "prefix": "segtree",
    "body": [
      "template <class T>",
      "struct segtree {",
      "    const int N; vector<T> tree;",
      "    segtree(int n) : N(1<<(__lg(n)+1)), tree(2*N) {}",
      "    void update(int pos, T x) {",
      "        for (int i = pos+N; i > 0; i >>= 1) ckmax(tree[i], x);",
      "    }",
      "    T query(int node, int nl, int nr, int ql, int qr) {",
      "        if (ql > nr || qr < nl) return 0;",
      "        if (ql <= nl && nr <= qr) return tree[node];",
      "        int mid = (nl+nr)/2;",
      "        return max(query(node*2, nl, mid, ql, qr), query(node*2+1, mid+1, nr, ql, qr));",
      "    }",
      "    T query(int l, int r) { return query(1, 0, N-1, l, r); }",
      "};",
      ""
    ],
    "description": "Snippet for Segtree"
  },
  "Lazyseg Iterative": {
    "prefix": "lazyseg_iterative",
    "body": [
      "const ll MX = 1e5+5;",
      "ll n, a[MX], t[MX*3], mk[MX*3];",
      "",
      "void build(ll l, ll r, ll p) {",
      "    if(l == r) {",
      "        t[p] = a[l];",
      "        return;",
      "    }",
      "    ll m = l + ((r-l)>>1);",
      "    build(l, m, p<<1), build(m+1, r, (p<<1)|1);",
      "    t[p] = t[p<<1] + t[(p<<1)|1];",
      "}",
      "",
      "void push(ll tl, ll tr, ll p, ll m) {",
      "    if(mk[p]) {",
      "        t[p<<1] += mk[p]*(m-tl+1), t[(p<<1)|1] += mk[p]*(tr-m);",
      "        mk[p<<1] += mk[p], mk[(p<<1)|1] += mk[p];",
      "    }",
      "    mk[p] = 0;",
      "}",
      "",
      "void update(ll l, ll r, ll tl, ll tr, ll p, ll c) {",
      "    if(l<=tl && tr<=r) {",
      "        t[p] += (tr-tl+1)*c, mk[p]+=c;",
      "        return;",
      "    }",
      "    ll m = tl + ((tr-tl)>>1);",
      "    push(tl, tr, p, m);",
      "    if(l<=m) update(l, r, tl, m, p<<1, c);",
      "    if(r>m) update(l, r, m+1, tr, (p<<1)|1, c);",
      "    t[p] = t[p<<1] + t[(p<<1)|1];",
      "}",
      "",
      "ll getsum(ll l, ll r, ll tl, ll tr, ll p) {",
      "    if(l<=tl && tr<=r) return t[p];",
      "    ll sum = 0;",
      "    ll m = tl + ((tr-tl)>>1);",
      "    push(tl, tr, p, m);",
      "    if(l<=m) sum+=getsum(l, r, tl, m, p<<1);",
      "    if(r>m) sum+=getsum(l, r, m+1, tr, (p<<1)|1);",
      "    return sum;",
      "}"
    ],
    "description": "Snippet for Lazyseg Iterative"
  },
  "Leetcode": {
    "prefix": "leetcode",
    "body": [
      "#define sz(x) (int)x.size()",
      "#define ll long long",
      "#define ar array",
      "#define all(x) x.begin(), x.end()",
      "#define pii pair<ll, ll>",
      "#define pb push_back",
      "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
      "#define rint(l, r) uniform_int_distribution<int>(l, r)(rng)",
      "template<typename T> bool ckmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }",
      "template<typename T> bool ckmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }",
      "template<typename T, typename S> constexpr T ifloor(const T a, const S b){return a/b-(a%b&&(a^b)<0);}",
      "template<typename T, typename S> constexpr T iceil(const T a, const S b){return ifloor(a+b-1,b);}",
      "template<typename T> T isqrt(const T &x){T y=sqrt(x+2); while(y*y>x) y--; return y;}",
      "template<typename T>",
      "void sort_unique(vector<T> &vec){",
      "    sort(vec.begin(),vec.end());",
      "    vec.resize(unique(vec.begin(),vec.end())-vec.begin()); ",
      "}",
      "struct _debug {",
      "template<typename T> static void __print(const T &x) {",
      "    if constexpr (is_convertible_v<T, string> || is_fundamental_v<T>) cout << x;",
      "    else { cout << '{'; int f{}; for (auto i : x) cout << (f++?\",\":\"\"), __print(i); cout << '}'; }",
      "}",
      "template<typename T, typename V>",
      "static void __print(const pair<T, V> &x) { cout << '(', __print(x.first), cout << ',', __print(x.second), cout << ')'; }",
      "template<typename T, typename... V>",
      "static void _print(const T& t, const V&... v) { __print(t); if constexpr (sizeof...(v)) cout << \", \", _print(v...); else cout << \"]\\n\"; }",
      "};",
      "#define debug(x...) cout << \"[\" << #x << \"] = [\", _debug::_print(x)"
    ],
    "description": "Snippet for Leetcode"
  },
  "Fenwick": {
    "prefix": "fenwick",
    "body": [
      "template<typename T> struct fenwick {",
      "    int n; vector<T> bit;",
      "    fenwick(int a) : n(a), bit(a+1) {}",
      "    T sum(int pos) {",
      "        T s = 0;",
      "        for (; pos; s += bit[pos], pos -= pos&-pos);",
      "        return s;",
      "    }",
      "    T query(int l, int r) {",
      "        return sum(r+1) - sum(l);",
      "    }",
      "    void update(int pos, T x) {",
      "        pos++;",
      "        for (; pos <= n; bit[pos] += x, pos += pos&-pos);",
      "    }",
      "};",
      "",
      "//outside is all 0-indexed, inclusive, so [l, r]",
      "//don't add 1 to update;"
    ],
    "description": "Snippet for Fenwick"
  },
  "Linearsieve": {
    "prefix": "linearsieve",
    "body": [
      "template <int N>",
      "struct sieve {",
      "    vector<int> primes;",
      "    array<int, N+1> spf;",
      "    sieve() : spf() {",
      "        for (int i = 2; i <= N; i++) {",
      "            if (!spf[i]) {",
      "                spf[i] = i;",
      "                primes.push_back(i);",
      "            }",
      "            for (int j = 0; i * primes[j] <= N; j++) {",
      "                spf[i*primes[j]] = primes[j];",
      "                if (primes[j] == spf[i]) break;",
      "            }",
      "        }",
      "    }",
      "    bool prime(int x) const {",
      "        return spf[x] == x;",
      "    }",
      "    vector<int> facs(int x) const {",
      "        vector<int> ret;",
      "        while (x != 1) {",
      "            ret.push_back(spf[x]);",
      "            x /= spf[x];",
      "        }",
      "        return ret;",
      "    }",
      "    vector<array<int, 2>> facs2(int x) const {",
      "        vector<array<int, 2>> ret;",
      "        while (x != 1) {",
      "            if (!ret.empty() && ret.back()[0] == spf[x]) ret.back()[1]++;",
      "            else ret.push_back({spf[x], 1});",
      "            x /= spf[x];",
      "        }",
      "        return ret;",
      "    }",
      "    vector<int> divs(int x) const {",
      "        vector<int> divisors(1, 1);",
      "        while (x > 1) {",
      "            int p = spf[x], c = 0;",
      "            while (x % p == 0) x /= p, c++;",
      "            int sz = divisors.size();",
      "            divisors.reserve(sz*(c+1));",
      "            for (int i = 1, pw = p; i <= c; i++, pw *= p) {",
      "                for (int j = 0; j < sz; j++) {",
      "                    divisors.push_back(divisors[j] * pw);",
      "                }",
      "            }",
      "        }",
      "        return divisors;",
      "    }",
      "};"
    ],
    "description": "Snippet for Linearsieve"
  },
  "Segtree Iterative": {
    "prefix": "segtree_iterative",
    "body": [
      "struct segtree {",
      "    int n; vector<int> t;",
      "    segtree(int siz) {",
      "        n = siz;",
      "        t.assign(2 * n, 0);",
      "        for(int i = n-1; i>=0; i--) t[i] = min(t[i<<1], t[i<<1|1])",
      "    }",
      "",
      "    void update(int p, int val) {",
      "        for(t[p+=n] = val; p > 1; p >>= 1) t[p>>1] = min(t[p], t[p^1]);",
      "    }",
      "",
      "    int query(int l, int r) {",
      "        int res = 4e18;",
      "        for(l += n, r += n; l < r; l >>= 1, r >>= 1) {",
      "            if(l&1) ckmin(res, t[l++]);",
      "            if(r&1) ckmin(res, t[--r]);",
      "        }",
      "        return res;",
      "    }",
      "};"
    ],
    "description": "Snippet for Segtree Iterative"
  },
  "Sparse": {
    "prefix": "sparse",
    "body": [
      "template<typename it, typename bin_op>",
      "struct sparse_table {",
      "    using T = typename remove_reference<decltype(*declval<it>())>::type;",
      "    vector<vector<T>> t; bin_op F;",
      " ",
      "    sparse_table(it first, it last, bin_op op) : t(1), F(op) {",
      "        int n = distance(first, last);",
      "        t.assign(32-__builtin_clz(n), vector<T>(n));",
      "        t[0].assign(first, last);",
      "        for (int i = 1; i < sz(t); i++)",
      "            for (int j = 0; j < n-(1<<i)+1; j++)",
      "                t[i][j] = F(t[i-1][j], t[i-1][j+(1<<(i-1))]);",
      "    }",
      " ",
      "    T query(int l, int r) {",
      "        int h = 31 - __builtin_clz(r-l+1);",
      "        return F(t[h][l], t[h][r-(1<<h)+1]);",
      "    }",
      "};"
    ],
    "description": "Snippet for Sparse"
  },
  "Lazyseg Min": {
    "prefix": "lazyseg_min",
    "body": [
      "template<class T> struct segtree {",
      "    const int N; vector<T> tree, lazy;",
      "    segtree(int n) : N(1<<(__lg(n)+1)), tree(2*N), lazy(2*N) {}",
      "    void push(int node) {",
      "        if (lazy[node]) {",
      "            tree[node] += lazy[node];",
      "            if (node < N) lazy[node*2] += lazy[node], lazy[node*2+1] += lazy[node];",
      "            lazy[node] = 0;",
      "        }",
      "    }",
      "    void update(int node, int nl, int nr, int ql, int qr, T v) {",
      "        push(node);",
      "        if (ql > nr || qr < nl) return;",
      "        if (ql <= nl && nr <= qr) {",
      "            lazy[node] += v, push(node);",
      "            return;",
      "        }",
      "        int mid = (nl+nr)/2;",
      "        update(node*2, nl, mid, ql, qr, v);",
      "        update(node*2+1, mid+1, nr, ql, qr, v);",
      "        tree[node] = min(tree[node*2], tree[node*2+1]);",
      "    }",
      "    T query(int node, int nl, int nr, int ql, int qr) {",
      "        if (ql > nr || qr < nl) return numeric_limits<T>::max();",
      "        push(node);",
      "        if (ql <= nl && nr <= qr) return tree[node];",
      "        int mid = (nl+nr)/2;",
      "        return min(query(node*2, nl, mid, ql, qr), query(node*2+1, mid+1, nr, ql, qr));",
      "    }",
      "    void update(int l, int r, T v) { update(1, 0, N-1, l, r, v); }",
      "    T query(int l, int r) { return query(1, 0, N-1, l, r); }",
      "};"
    ],
    "description": "Snippet for Lazyseg Min"
  },
  "Dsu": {
    "prefix": "dsu",
    "body": [
      "struct DSU {",
      "    vector<int> f, siz;",
      "    ",
      "    DSU() {}",
      "    DSU(int n) {",
      "        init(n);",
      "    }",
      "    ",
      "    void init(int n) {",
      "        f.resize(n);",
      "        iota(f.begin(), f.end(), 0);",
      "        siz.assign(n, 1);",
      "    }",
      "    ",
      "    int find(int x) {",
      "        while (x != f[x]) {",
      "            x = f[x] = f[f[x]];",
      "        }",
      "        return x;",
      "    }",
      "    ",
      "    bool same(int x, int y) {",
      "        return find(x) == find(y);",
      "    }",
      "    ",
      "    bool merge(int x, int y) {",
      "        x = find(x);",
      "        y = find(y);",
      "        if (x == y) {",
      "            return false;",
      "        }",
      "        siz[x] += siz[y];",
      "        f[y] = x;",
      "        return true;",
      "    }",
      "    ",
      "    int size(int x) {",
      "        return siz[find(x)];",
      "    }",
      "};"
    ],
    "description": "Snippet for Dsu"
  },
  "Matrix": {
    "prefix": "matrix",
    "body": [
      "template<typename T, class Add, class Mul>",
      "struct matrix {",
      "    int n;",
      "    vector<T> a;",
      "    Add add;",
      "    Mul mul;",
      "    T add_id;",
      "    T mul_id;",
      "    matrix(int _n, Add _add, Mul _mul, T _add_id, T _mul_id)",
      "        : n(_n), a(n * n), add(_add), mul(_mul), add_id(_add_id), mul_id(_mul_id) {}",
      "    static matrix identity(int n, Add add, Mul mul, T add_id, T mul_id) {",
      "        matrix m(n, add, mul, add_id, mul_id);",
      "        for (int i = 0; i < n; ++i) m(i,i) = mul_id;",
      "        return m;",
      "    }",
      "    T& operator()(int i, int j) { return a[i * n + j]; }",
      "    T operator()(int i, int j) const { return a[i * n + j]; }",
      "    matrix operator*(const matrix &rhs) const {",
      "        matrix res(n, add, mul, add_id, mul_id);",
      "        for (int i = 0; i < n * n; ++i) res.a[i] = add_id;",
      "        for (int i = 0; i < n; ++i) {",
      "            for (int k = 0; k < n; ++k) {",
      "                T x = (*this)(i,k);",
      "                for (int j = 0; j < n; ++j) {",
      "                    res(i,j) = add(res(i,j), mul(x, rhs(k,j)));",
      "                }",
      "            }",
      "        }",
      "        return res;",
      "    }",
      "    matrix pow(long long e) const {",
      "        matrix base = *this;",
      "        matrix res = identity(n, add, mul, add_id, mul_id);",
      "        while (e > 0) {",
      "            if (e & 1) res = res * base;",
      "            base = base * base;",
      "            e >>= 1;",
      "        }",
      "        return res;",
      "    }",
      "    vector<T> apply(const vector<T> &v) const {",
      "        vector<T> out(n, add_id);",
      "        for (int i = 0; i < n; ++i) {",
      "            for (int j = 0; j < n; ++j) {",
      "                out[i] = add(out[i], mul((*this)(i,j), v[j]));",
      "            }",
      "        }",
      "        return out;",
      "    }",
      "};"
    ],
    "description": "Snippet for Matrix"
  },
  "Mint": {
    "prefix": "mint",
    "body": [
      "template <int MOD_> struct modnum {",
      "    static constexpr int MOD = MOD_;",
      "",
      "    int v;",
      "",
      "    modnum() : v(0) {}",
      "    modnum(int v_) : v(v_ % MOD) { if (v < 0) v += MOD; }",
      "",
      "    explicit operator int() const { return v; }",
      "    explicit operator bool() const { return v; }",
      "",
      "    friend ostream& operator << (ostream& out, const modnum& n) { return out << n.v; }",
      "    friend istream& operator >> (istream& in, modnum& n) { int v_; in >> v_; n = modnum(v_); return in; }",
      "",
      "    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }",
      "    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }",
      "",
      "    modnum operator- () const {",
      "        return neg();",
      "    }",
      "    modnum operator+ () const {",
      "        return modnum(*this);",
      "    }",
      "",
      "    modnum& operator ++ () {",
      "        v++;",
      "        if (v == MOD) v = 0;",
      "        return *this;",
      "    }",
      "    modnum& operator -- () {",
      "        if (v == 0) v = MOD;",
      "        v--;",
      "        return *this;",
      "    }",
      "    modnum& operator += (const modnum& o) {",
      "        v -= MOD-o.v;",
      "        v = (v < 0) ? v + MOD : v;",
      "        return *this;",
      "    }",
      "    modnum& operator -= (const modnum& o) {",
      "        v -= o.v;",
      "        v = (v < 0) ? v + MOD : v;",
      "        return *this;",
      "    }",
      "    modnum& operator *= (const modnum& o) {",
      "        v = v * o.v % MOD;",
      "        return *this;",
      "    }",
      "",
      "    friend modnum binpow(modnum a, int p) {",
      "        if (p == 0) return 1;",
      "        modnum ret = 1;",
      "        for (; p; p /= 2, a *= a) if (p&1) ret *= a;",
      "        return ret;",
      "    }",
      "",
      "    modnum inv() const {",
      "        return binpow(*this, MOD-2);",
      "    }",
      "    friend modnum inv(const modnum& m) { return m.inv(); }",
      "",
      "    modnum& operator /= (const modnum& o) {",
      "        return *this *= o.inv();",
      "    }",
      "",
      "    modnum neg() const {",
      "        modnum res;",
      "        res.v = v ? MOD-v : 0;",
      "        return res;",
      "    }",
      "    friend modnum neg(const modnum& m) { return m.neg(); }",
      "",
      "    friend modnum operator ++ (modnum& a, int32_t) { modnum r = a; ++a; return r; }",
      "    friend modnum operator -- (modnum& a, int32_t) { modnum r = a; --a; return r; }",
      "    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }",
      "    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }",
      "    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }",
      "    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }",
      "};",
      "",
      "const int mod = 1e9+7;",
      "using mint = modnum<mod>;",
      "",
      "vector<mint> facs, invfacs;",
      "",
      "mint choose(int _a, int _b) {",
      "    if (_b > _a || _a < 0 || _b < 0) return 0;",
      "    return facs[_a] * invfacs[_b] * invfacs[_a-_b];",
      "}",
      "",
      "void finit(const int nx) {",
      "    facs.resize(nx+1);",
      "    invfacs.resize(nx+1);",
      "    facs[0] = facs[1] = invfacs[0] = invfacs[1] = 1;",
      "    for (int i = 2; i <= nx; i++) {",
      "        facs[i] = facs[i-1] * mint(i);",
      "    }",
      "    invfacs[nx] = inv(facs[nx]);",
      "    for (int i = nx-1; i > 1; i--) {",
      "        invfacs[i] = invfacs[i+1] * mint(i+1);",
      "    }",
      "}"
    ],
    "description": "Snippet for Mint"
  },
  "Hash": {
    "prefix": "hash",
    "body": [
      "const int hash_mod = 1e9+7;",
      "int binpow(int a, int b) {",
      "    int r = 1;",
      "    for (; b > 0; b >>= 1, a = (long long)a*a%hash_mod) if (b&1) r = (long long)r*a%hash_mod;",
      "    return r;",
      "}",
      "const int b_N = 2;",
      "bool init_ = 0;",
      "array<int, b_N> bases;",
      "void init() {",
      "    for (int i = 0; i < b_N; i++) {",
      "        bases[i] = rint(2, hash_mod-1);",
      "    }",
      "}",
      "template<typename T> struct Hash {",
      "    array<vector<int>, b_N> pref, inv;",
      "    Hash(const T& s) {",
      "        if (!init_) init(), init_ = 1;",
      "        int n = s.size();",
      "        for (int i = 0; i < b_N; i++) {",
      "            pref[i].resize(n), inv[i].resize(n);",
      "            inv[i][n-1] = binpow(binpow(bases[i], n-1), hash_mod-2);",
      "            for (int j = n-2; j >= 0; j--) inv[i][j] = (long long)inv[i][j+1] * bases[i] % hash_mod;",
      "            for (int j = 0, b = 1; j < n; j++, b = (long long)b * bases[i] % hash_mod) {",
      "                pref[i][j] = (j?pref[i][j-1]:0) + (long long)b*(int(s[j])+2)%hash_mod;",
      "                if (pref[i][j] >= hash_mod) pref[i][j] -= hash_mod;",
      "            }",
      "        }",
      "    }",
      "    array<int, b_N> query(int l, int r) const {",
      "        array<int, b_N> ret;",
      "        for (int i = 0; i < b_N; i++) {",
      "            ret[i] = pref[i][r] - (l?pref[i][l-1]:0);",
      "            if (ret[i] < 0) ret[i] += hash_mod;",
      "            ret[i] = (long long)ret[i] * inv[i][l] % hash_mod;",
      "        }",
      "        return ret;",
      "    }",
      "};"
    ],
    "description": "Snippet for Hash"
  },
  "Lazyseg": {
    "prefix": "lazyseg",
    "body": [
      "template<class T> struct segtree {",
      "    const int N; vector<T> tree, lazy, size;",
      "    segtree(int n) : N(1<<(__lg(n)+1)), tree(2*N), lazy(2*N), size(2*N) {",
      "        for (int i = 0; i < n; i++) size[i+N] = 1;",
      "        for (int i = N-1; i >= 1; i--) size[i] = size[i*2] + size[i*2+1];",
      "    }",
      "    void push(int node) {",
      "        if (lazy[node]) {",
      "            tree[node] += lazy[node] * size[node];",
      "            if (node < N) lazy[node*2] += lazy[node], lazy[node*2+1] += lazy[node];",
      "            lazy[node] = 0;",
      "        }",
      "    }",
      "    void update(int node, int nl, int nr, int ql, int qr, T v) {",
      "        push(node);",
      "        if (ql > nr || qr < nl) return;",
      "        if (ql <= nl && nr <= qr) {",
      "            lazy[node] += v, push(node);",
      "            return;",
      "        }",
      "        int mid = (nl+nr)/2;",
      "        update(node*2, nl, mid, ql, qr, v);",
      "        update(node*2+1, mid+1, nr, ql, qr, v);",
      "        tree[node] = tree[node*2] + tree[node*2+1];",
      "    }",
      "    T query(int node, int nl, int nr, int ql, int qr) {",
      "        push(node);",
      "        if (ql > nr || qr < nl) return 0;",
      "        if (ql <= nl && nr <= qr) return tree[node];",
      "        int mid = (nl+nr)/2;",
      "        return query(node*2, nl, mid, ql, qr) + query(node*2+1, mid+1, nr, ql, qr);",
      "    }",
      "    void update(int l, int r, T v) { update(1, 0, N-1, l, r, v); }",
      "    T query(int l, int r) { return query(1, 0, N-1, l, r); }",
      "};"
    ],
    "description": "Snippet for Lazyseg"
  },
  "Rollbackdsu": {
    "prefix": "rollbackdsu",
    "body": [
      "struct RollbackUnionFind {",
      "  vector<int> data;",
      "  stack<pair<int, int> > history;",
      "  int inner_snap;",
      "",
      "  RollbackUnionFind(int sz) : inner_snap(0) { data.assign(sz, -1); }",
      "",
      "  bool unite(int x, int y) {",
      "    x = find(x), y = find(y);",
      "    history.emplace(x, data[x]);",
      "    history.emplace(y, data[y]);",
      "    if (x == y) return false;",
      "    if (data[x] > data[y]) swap(x, y);",
      "    data[x] += data[y];",
      "    data[y] = x;",
      "    return true;",
      "  }",
      "",
      "  int find(int k) {",
      "    if (data[k] < 0) return k;",
      "    return find(data[k]);",
      "  }",
      "",
      "  int same(int x, int y) { return find(x) == find(y); }",
      "",
      "  int size(int k) { return (-data[find(k)]); }",
      "",
      "  void undo() {",
      "    data[history.top().first] = history.top().second;",
      "    history.pop();",
      "    data[history.top().first] = history.top().second;",
      "    history.pop();",
      "  }",
      "",
      "  void snapshot() { inner_snap = int(history.size() >> 1); }",
      "",
      "  int get_state() { return int(history.size() >> 1); }",
      "",
      "  void rollback(int state = -1) {",
      "    if (state == -1) state = inner_snap;",
      "    state <<= 1;",
      "    assert(state <= (int)history.size());",
      "    while (state < (int)history.size()) undo();",
      "  }",
      "};"
    ],
    "description": "Snippet for Rollbackdsu"
  },
  "Trie": {
    "prefix": "trie",
    "body": [
      "struct trie {",
      "    int cnt{};",
      "    int nex[100001][26]{};",
      "    bool exist[100001]{};",
      "",
      "    void insert(string&s) {",
      "        int vtx = 0;",
      "        for(char c : s) {",
      "            int d = c-'a';",
      "            auto &nx = nex[vtx][d];",
      "            if(!nx) {",
      "                nx = ++cnt;",
      "            }",
      "            vtx = nx;",
      "        }",
      "        exist[vtx] = 1;",
      "    }",
      "",
      "    string search(string&s) {",
      "        int vtx = 0;",
      "        string ans;",
      "        for(char c : s) {  ",
      "            int d = c-'a';",
      "            ans+=c;",
      "            auto &nx = nex[vtx][d];",
      "            if(!nx) return s;",
      "            vtx = nx;  ",
      "            if(exist[vtx]) return ans;",
      "        }",
      "        return s;",
      "    }",
      "};"
    ],
    "description": "Snippet for Trie"
  },
  "Fwht": {
    "prefix": "fwht",
    "body": [
      "void fwht(vector<ll>& a, bool inv) {",
      "\tint w = __lg(sz(a));",
      "\tfor (int i = 0; i < w; i++) {",
      "\t\tfor (int j = 0; j < 1 << w; j += 1 << (i+1)) {",
      "\t\t\tfor (int k = 0; k < 1 << i; k++) {",
      "\t\t\t\tauto l = a[j+k], r = a[(j+k) ^ 1 << i];",
      "\t\t\t\ta[j+k] = (l + r) >> inv;",
      "\t\t\t\ta[(j+k) ^ 1 << i] = (l - r) >> inv;",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "Snippet for Fwht"
  },
  "Graphs Dfs Cycle": {
    "prefix": "dfs_cycle",
    "body": [
      "vector<int> color(n, 0);",
      "bool cycle = false;",
      "auto dfs = [&](auto &&s, int u) -> void {",
      "    color[u] = 1;",
      "    for (int v : adj[u]) {",
      "        if (color[v] == 0) s(s, v);",
      "        else if (color[v] == 1) cycle = true;",
      "    }",
      "    color[u] = 2;",
      "};",
      "for (int i = 0; i < n; i++) if (color[i] == 0) dfs(dfs, i);"
    ],
    "description": "Snippet for Graphs Dfs Cycle"
  },
  "Graphs Dijkstras": {
    "prefix": "dijkstras",
    "body": [
      "template<typename T>",
      "vector<T> dijkstra(int start, vector<vector<pair<int,T>>> &adj){",
      "    int n=sz(adj);",
      "    vector<T> dist(n,4e18); //change if needed",
      "    priority_queue<pair<T,int>,vector<pair<T,int>>,greater<pair<T,int>>> pq;",
      "    dist[start]=0, pq.push({0,start});",
      "    while(!pq.empty()){",
      "        auto [d,u] = pq.top(); pq.pop();",
      "        if(d != dist[u]) continue;",
      "        for(auto &[v,w]: adj[u]) if(ckmin(dist[v],d+w)){",
      "            pq.push({dist[v],v});",
      "        }",
      "    }",
      "    return dist;",
      "}",
      ""
    ],
    "description": "Snippet for Graphs Dijkstras"
  },
  "Graphs Lca": {
    "prefix": "lca",
    "body": [
      "// Problem: $(PROBLEM)",
      "// Contest: $(CONTEST)",
      "// URL: $(URL)",
      "// Time Limit: $(TIMELIM)",
      "// Start: $(DATE)",
      "",
      "#include <bits/stdc++.h>",
      "#define sz(x) (int)x.size()",
      "#define ll long long",
      "#define ar array",
      "#define all(x) x.begin(), x.end()",
      "#define pii pair<ll, ll>",
      "#define pb push_back",
      "using namespace std;",
      "#define rint(l, r) uniform_int_distribution<int>(l, r)(rng)",
      "template<typename T> bool ckmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }",
      "template<typename T> bool ckmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }",
      "",
      "#ifdef MISAKA",
      "struct _debug {",
      "template<typename T> static void __print(const T &x) {",
      "    if constexpr (is_convertible_v<T, string> || is_fundamental_v<T>) cerr << x;",
      "    else { cerr << '{'; int f{}; for (auto i : x) cerr << (f++?\",\":\"\"), __print(i); cerr << '}'; }",
      "}",
      "template<typename T, typename V>",
      "static void __print(const pair<T, V> &x) { cerr << '(', __print(x.first), cerr << ',', __print(x.second), cerr << ')'; }",
      "template<typename T, typename... V>",
      "static void _print(const T& t, const V&... v) { __print(t); if constexpr (sizeof...(v)) cerr << \", \", _print(v...); else cerr << \"]\\n\"; }",
      "};",
      "#define debug(x...) cerr << \"[\" << #x << \"] = [\", _debug::_print(x)",
      "#else",
      "#define debug(x...)",
      "#endif",
      "",
      "const char nl = '\\n';",
      "const int INF = 0x3f3f3f3f;",
      "",
      "void shiina_mashiro() {",
      "    //n nodes, n-1 edges, given q queries, find lca(x, y);",
      "    ",
      "    int n; cin >> n;",
      "    vector<vector<int>> adj(n+1);",
      "    for(int i = 0; i < n-1; i++) {",
      "        int uu, vv; cin >> uu >> vv;",
      "        adj[uu].pb(vv);",
      "        adj[vv].pb(uu);",
      "    }",
      "",
      "    vector<int> dep(n+1, 0);",
      "    vector up(n+1, vector<int>(31, 0)); //up[i][j] := 2^j th ancestor of node i;",
      "",
      "    auto dfs = [&](auto&&s, int u, int p) -> void { ",
      "        up[u][0] = p;",
      "        dep[u] = dep[p] + 1;",
      "        for(int j = 1; j < 31; j++) {",
      "            up[u][j] = up[up[u][j-1]][j-1]; //up[7][0] = 6 up[7][1] = up[6][0] = 5, up[7][2] = up[5][1] = 3....",
      "        }",
      "",
      "        for(int j = 0; j < sz(adj[u]); j++) {",
      "            if(adj[u][j] != p) s(s, adj[u][j], u);",
      "        }",
      "    };",
      "",
      "    ",
      "    dfs(dfs, 1, 0);",
      "    debug(dep, up, adj);",
      "    auto lca = [&](int x, int y) -> int {",
      "        if(dep[x] > dep[y]) swap(x, y);",
      "        int diff = dep[y] - dep[x];",
      "",
      "        for(int j = 0; diff; diff>>=1, j++) {",
      "            if(diff & 1) {",
      "                y = up[y][j];",
      "            }",
      "        }",
      "        if(x==y) return x;",
      "        for(int j = 30; j>=0 && x != y; j--) {",
      "            if(up[x][j] != up[y][j]) {",
      "                x = up[x][j];",
      "                y = up[y][j];",
      "            }",
      "        }",
      "        return up[x][0];",
      "    };",
      "",
      "    auto path = [&](int x, int y) -> int {",
      "",
      "    }",
      "    ",
      "    int m; cin >> m;",
      "    for(;m--;) {",
      "        int a, b; cin >> a >> b;",
      "        cout << lca(a, b) << nl;",
      "    }",
      "}",
      "",
      "int main() {",
      "    cin.tie(0)->sync_with_stdio(0);",
      "    //freopen(\"perimeter.in\",\"r\",stdin); freopen(\"perimeter.out\",\"w\",stdout);",
      "    int t = 1;",
      "    //cin >> t;",
      "    while (t--) shiina_mashiro();",
      "}",
      ""
    ],
    "description": "Snippet for Graphs Lca"
  }
}